<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Trellis 3D Model Generator (Direct Client)</title>
    <link rel="stylesheet" href="style.css">
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/examples/js/loaders/GLTFLoader.js"></script>
</head>
<body>
    <div class="container">
        <h1>Trellis 3D Model Generator (Direct Client)</h1>
        
        <div class="upload-section">
            <h2>Upload an Image</h2>
            <p>Upload an image to generate a 3D model (max size: 1024x1024)</p>
            
            <div class="drop-area" id="dropArea">
                <p>Drag & drop an image here or</p>
                <label for="fileInput" class="file-input-label">Choose a file</label>
                <input type="file" id="fileInput" accept="image/*" hidden>
                <div id="preview" class="preview-container"></div>
            </div>
            
            <button id="generateBtn" disabled>Generate 3D Model</button>
        </div>

        <div class="status-section" id="statusSection">
            <h2>Generation Status</h2>
            <div id="statusMessage">No generation in progress</div>
            <div id="progressContainer" class="progress-container">
                <div id="progressBar" class="progress-bar"></div>
            </div>
        </div>
        
        <div class="model-viewer-section" id="modelViewerSection">
            <h2>3D Model Viewer</h2>
            <div id="modelViewer" class="model-viewer"></div>
            <div class="controls-info">
                <p>Controls: Left click + drag to rotate | Right click + drag to pan | Scroll to zoom</p>
            </div>
        </div>
    </div>
    
    <script>
        // DOM Elements
        const dropArea = document.getElementById('dropArea');
        const fileInput = document.getElementById('fileInput');
        const preview = document.getElementById('preview');
        const generateBtn = document.getElementById('generateBtn');
        const statusMessage = document.getElementById('statusMessage');
        const progressBar = document.getElementById('progressBar');
        const modelViewer = document.getElementById('modelViewer');

        // Global variables
        let uploadedImage = null;
        let scene, camera, renderer, controls, model;
        let taskId = null;
        let statusCheckInterval = null;

        // API Constants - Direct call to API
        const API_URL = 'https://api.piapi.ai/api/v1/task';
        const API_KEY = '69b943f6943732dcf9fc66cf7536bc8288b3d980bfd988a3f03e299565a76efd';

        // Initialize 3D viewer
        initializeViewer();

        // Setup event listeners
        setupEventListeners();

        function setupEventListeners() {
            // Drag and drop events
            ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
                dropArea.addEventListener(eventName, preventDefaults, false);
            });

            ['dragenter', 'dragover'].forEach(eventName => {
                dropArea.addEventListener(eventName, highlight, false);
            });

            ['dragleave', 'drop'].forEach(eventName => {
                dropArea.addEventListener(eventName, unhighlight, false);
            });

            dropArea.addEventListener('drop', handleDrop, false);
            fileInput.addEventListener('change', handleFileSelect, false);
            dropArea.addEventListener('click', () => fileInput.click(), false);
            generateBtn.addEventListener('click', generateModel, false);
            
            // Display any errors in the console
            window.addEventListener('error', function(event) {
                console.error('Global error caught:', event.error);
                statusMessage.textContent = `Error: ${event.error.message}`;
            });
        }

        function preventDefaults(e) {
            e.preventDefault();
            e.stopPropagation();
        }

        function highlight() {
            dropArea.classList.add('active');
        }

        function unhighlight() {
            dropArea.classList.remove('active');
        }

        function handleDrop(e) {
            const dt = e.dataTransfer;
            const files = dt.files;
            handleFiles(files);
        }

        function handleFileSelect(e) {
            const files = e.target.files;
            handleFiles(files);
        }

        function handleFiles(files) {
            if (files.length > 0) {
                const file = files[0];
                if (file.type.match('image.*')) {
                    uploadedImage = file;
                    displayPreview(file);
                    generateBtn.disabled = false;
                } else {
                    alert('Please upload an image file.');
                }
            }
        }

        function displayPreview(file) {
            preview.innerHTML = '';
            const img = document.createElement('img');
            img.file = file;
            preview.appendChild(img);

            const reader = new FileReader();
            reader.onload = (e) => { img.src = e.target.result; };
            reader.readAsDataURL(file);
        }

        function fileToBase64(file) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = () => {
                    // Extract the base64 data from the data URL
                    const base64String = reader.result.split(',')[1];
                    resolve(base64String);
                };
                reader.onerror = error => reject(error);
                reader.readAsDataURL(file);
            });
        }

        async function generateModel() {
            if (!uploadedImage) {
                alert('Please upload an image first.');
                return;
            }

            // Update UI for processing state
            generateBtn.disabled = true;
            statusMessage.textContent = 'Converting image...';
            progressBar.style.width = '10%';

            try {
                // Convert the image to base64
                const base64Image = await fileToBase64(uploadedImage);
                console.log('Image converted to base64');
                
                statusMessage.textContent = 'Sending to Trellis API...';
                progressBar.style.width = '20%';
                
                console.log('Sending request to API directly...');
                // Create the API request
                const response = await fetch(API_URL, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'x-api-key': API_KEY
                    },
                    body: JSON.stringify({
                        model: 'Qubico/trellis',
                        task_type: 'image-to-model',
                        input: {
                            image: base64Image
                        }
                    })
                });

                // Get the text response first to examine it
                const responseText = await response.text();
                console.log('API direct response text:', responseText);
                
                // Try to parse as JSON
                let rawData;
                try {
                    rawData = JSON.parse(responseText);
                    console.log('Successfully parsed API response as JSON:', rawData);
                } catch (e) {
                    console.error('Error parsing response as JSON:', e);
                    throw new Error(`Invalid response format from API: ${responseText.substring(0, 100)}...`);
                }

                if (!response.ok) {
                    console.error('API returned error status:', response.status);
                    throw new Error(`API error: ${rawData.error || response.status}`);
                }
                
                // Extract task_id according to the exact pattern we're seeing
                let extractedTaskId = null;
                
                // Check for the specific {"code":200, "data":{"task_id":"..."}, "message":"success"} structure
                if (rawData.code === 200 && rawData.data && rawData.message === "success") {
                    console.log('Found expected API response structure: code 200 with data property and success message');
                    
                    if (rawData.data.task_id) {
                        extractedTaskId = rawData.data.task_id;
                        console.log('Extracted task_id from nested data:', extractedTaskId);
                    } else if (rawData.data.id) {
                        extractedTaskId = rawData.data.id;
                        console.log('Using id as task_id from nested data:', extractedTaskId);
                    }
                } 
                // Fallback to other possible response structures
                else if (rawData.task_id) {
                    extractedTaskId = rawData.task_id;
                    console.log('Found task_id directly in response:', extractedTaskId);
                } else if (rawData.id) {
                    extractedTaskId = rawData.id;
                    console.log('Using id as task_id:', extractedTaskId);
                }
                
                // Verify we have a task_id
                if (!extractedTaskId) {
                    console.error('No task_id found in any field of the response:', rawData);
                    throw new Error(`No task ID found in API response. Full response: ${JSON.stringify(rawData)}`);
                }
                
                // Store the task ID and start polling
                taskId = extractedTaskId;
                window.taskId = taskId; // Store in window for debugging
                statusMessage.textContent = 'Processing image (this may take a few minutes)...';
                progressBar.style.width = '30%';
                
                // Start polling for status
                startStatusPolling();
            } catch (error) {
                console.error('Error generating model:', error);
                statusMessage.textContent = `Error: ${error.message.substring(0, 100)}${error.message.length > 100 ? '...' : ''}`;
                generateBtn.disabled = false;
                progressBar.style.width = '0%';
            }
        }

        function startStatusPolling() {
            // Clear any existing interval
            if (statusCheckInterval) {
                clearInterval(statusCheckInterval);
            }
            
            // Set a new interval to check status every 5 seconds
            statusCheckInterval = setInterval(checkTaskStatus, 5000);
        }

        async function checkTaskStatus() {
            try {
                if (!taskId) {
                    console.error('No task ID available for status check');
                    statusMessage.textContent = 'Error: No task ID available';
                    clearInterval(statusCheckInterval);
                    generateBtn.disabled = false;
                    return;
                }
                
                console.log('Checking status for task:', taskId);
                statusMessage.textContent = `Checking status for task: ${taskId}...`;
                
                // Use the correct URL format for status checks - append the task_id to the path
                const statusUrl = `${API_URL}/${taskId}`;
                console.log('Status check URL:', statusUrl);
                
                const response = await fetch(statusUrl, {
                    method: 'GET',
                    headers: {
                        'x-api-key': API_KEY
                    }
                });

                // Get the text response first to examine it
                const responseText = await response.text();
                console.log('Status response text:', responseText);
                
                // Try to parse as JSON
                let rawData;
                try {
                    rawData = JSON.parse(responseText);
                    console.log('Successfully parsed status response as JSON:', rawData);
                } catch (e) {
                    console.error('Error parsing status response as JSON:', e);
                    throw new Error(`Invalid status response format from API: ${responseText.substring(0, 100)}...`);
                }

                if (!response.ok) {
                    console.error('Status check returned error:', response.status);
                    throw new Error(`API error: ${rawData.error || response.status}`);
                }
                
                // Extract status and output according to the response structure
                let status = null;
                let output = null;
                
                // Check for the specific {"code":200, "data":{"status":"...", "output":...}, "message":"success"} structure
                if (rawData.code === 200 && rawData.data && rawData.message === "success") {
                    console.log('Found expected status response structure: code 200 with data property and success message');
                    status = rawData.data.status;
                    output = rawData.data.output;
                } 
                // Fallback to other response structures
                else {
                    status = rawData.status;
                    output = rawData.output;
                }
                
                console.log('Extracted status:', status);
                console.log('Extracted output:', output);
                
                // Update progress based on status
                if (status === 'succeeded' || status === 'completed') {
                    clearInterval(statusCheckInterval);
                    statusMessage.textContent = 'Model generated successfully!';
                    progressBar.style.width = '100%';
                    
                    // Load the 3D model
                    if (output && output.model_file) {
                        loadModel(output.model_file);
                    } else {
                        throw new Error('No model file in the response');
                    }
                    
                    generateBtn.disabled = false;
                } else if (status === 'failed' || status === 'error') {
                    clearInterval(statusCheckInterval);
                    statusMessage.textContent = 'Model generation failed.';
                    progressBar.style.width = '0%';
                    generateBtn.disabled = false;
                } else {
                    // Still processing
                    statusMessage.textContent = `Processing: ${status || 'in progress'}`;
                    progressBar.style.width = '50%';
                }
            } catch (error) {
                console.error('Error checking task status:', error);
                statusMessage.textContent = `Error checking status: ${error.message.substring(0, 100)}${error.message.length > 100 ? '...' : ''}`;
                clearInterval(statusCheckInterval);
                generateBtn.disabled = false;
            }
        }

        function initializeViewer() {
            // Create scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0xf0f0f0);

            // Create camera
            camera = new THREE.PerspectiveCamera(75, modelViewer.clientWidth / modelViewer.clientHeight, 0.1, 1000);
            camera.position.z = 5;

            // Create renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(modelViewer.clientWidth, modelViewer.clientHeight);
            modelViewer.appendChild(renderer.domElement);

            // Add lighting
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
            scene.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(0, 1, 1);
            scene.add(directionalLight);

            // Add controls
            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.25;
            controls.screenSpacePanning = false;
            controls.maxPolarAngle = Math.PI;
            controls.minDistance = 1;
            controls.maxDistance = 10;

            // Handle window resize
            window.addEventListener('resize', onWindowResize, false);

            // Add initial cube to show the viewer is working
            const geometry = new THREE.BoxGeometry(1, 1, 1);
            const material = new THREE.MeshStandardMaterial({ color: 0x3498db });
            const cube = new THREE.Mesh(geometry, material);
            scene.add(cube);
            
            // Animate the scene
            animate();
        }

        function loadModel(modelUrl) {
            // Clear existing model
            if (model) {
                scene.remove(model);
            }

            // Create a loader
            const loader = new THREE.GLTFLoader();
            
            // Load the model
            loader.load(
                modelUrl,
                function (gltf) {
                    model = gltf.scene;
                    
                    // Center the model
                    const box = new THREE.Box3().setFromObject(model);
                    const center = box.getCenter(new THREE.Vector3());
                    model.position.x = -center.x;
                    model.position.y = -center.y;
                    model.position.z = -center.z;
                    
                    // Add the model to the scene
                    scene.add(model);
                    
                    // Adjust camera to fit the model
                    const size = box.getSize(new THREE.Vector3());
                    const maxDim = Math.max(size.x, size.y, size.z);
                    camera.position.set(maxDim * 2, maxDim * 2, maxDim * 2);
                    camera.lookAt(0, 0, 0);
                    
                    // Reset controls target to model center
                    controls.target.set(0, 0, 0);
                    controls.update();
                },
                function (xhr) {
                    // Progress
                    const percent = Math.round((xhr.loaded / xhr.total) * 100);
                    statusMessage.textContent = `Loading model: ${percent}%`;
                },
                function (error) {
                    console.error('Error loading model:', error);
                    statusMessage.textContent = 'Error loading model';
                }
            );
        }

        function onWindowResize() {
            camera.aspect = modelViewer.clientWidth / modelViewer.clientHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(modelViewer.clientWidth, modelViewer.clientHeight);
        }

        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera);
        }
    </script>
</body>
</html> 