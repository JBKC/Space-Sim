<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Extract Himalayas Terrain Patch</title>
    <style>
        body { font-family: Arial, sans-serif; margin: 20px; }
        button { padding: 8px 16px; margin: 5px; }
        #result { padding: 10px; border: 1px solid #ccc; border-radius: 4px; min-height: 100px; }
    </style>
</head>
<body>
    <h1>Extract 100m² Terrain Patch from Himalayas</h1>
    <button id="extractPatchBtn">Extract and Save Terrain Patch</button>
    <div id="result">Status will appear here...</div>
    
    <script type="importmap">
        {
            "imports": {
                "@here/quantized-mesh-decoder": "https://unpkg.com/@here/quantized-mesh-decoder@1.0.0/index.js"
            }
        }
    </script>
    <script type="module">
        import decode from '@here/quantized-mesh-decoder';

        // Constants
        const API_KEY = '7lEaUMnLqxOJqBmrGAKw'; // Replace with your MapTiler API key if needed
        const ZOOM = 15; // Zoom level for detailed terrain
        const PATCH_SIZE_METERS = 10; // Side length of the square patch in meters (100m² area)

        // Mount Everest coordinates (as a central point in the Himalayas)
        const CENTER_LAT = 27.9881; // Latitude
        const CENTER_LON = 86.9250; // Longitude

        // Earth's radius in meters (for distance calculations)
        const EARTH_RADIUS = 6371000;

        // Helper functions
        function degToRad(deg) {
            return deg * (Math.PI / 180);
        }

        function calculateTileCoordinates(lat, lon, zoom) {
            const latRad = degToRad(lat);
            const n = Math.pow(2, zoom);
            const x = Math.floor(((lon + 180) / 360) * n);
            const y = Math.floor((1 - Math.log(Math.tan(latRad) + 1 / Math.cos(latRad)) / Math.PI) / 2 * n);
            return { x, y };
        }

        function metersToLonLat(meters, lat) {
            // Approximate conversion from meters to degrees
            const latMetersPerDegree = 111132.92 - 559.82 * Math.cos(2 * degToRad(lat)) + 1.175 * Math.cos(4 * degToRad(lat));
            const lonMetersPerDegree = 111412.84 * Math.cos(degToRad(lat)) - 93.5 * Math.cos(3 * degToRad(lat));
            return {
                lon: meters / lonMetersPerDegree,
                lat: meters / latMetersPerDegree
            };
        }

        function showStatus(message) {
            document.getElementById('result').innerHTML = message;
        }

        function showError(error) {
            showStatus(`<strong style="color:red">Error:</strong> ${error.message}`);
            console.error('Error details:', error);
        }

        async function fetchTerrainTile(z, x, y) {
            const url = `https://api.maptiler.com/tiles/terrain-quantized-mesh-v2/${z}/${x}/${y}.terrain?key=${API_KEY}`;
            try {
                console.log(`Fetching tile z=${z}, x=${x}, y=${y}`);
                const response = await fetch(url);
                if (!response.ok) throw new Error(`HTTP error! Status: ${response.status}`);
                return await response.arrayBuffer();
            } catch (error) {
                showError(error);
                return null;
            }
        }

        function extractPatch(decodedData, centerLat, centerLon, patchSizeMeters) {
            const { header, vertexData, triangleIndices } = decodedData;
            const { west, south, east, north, minHeight, maxHeight } = header;

            // Calculate the bounding box for the 100m² patch
            const delta = metersToLonLat(patchSizeMeters / 2, centerLat);
            const patchWest = centerLon - delta.lon;
            const patchEast = centerLon + delta.lon;
            const patchSouth = centerLat - delta.lat;
            const patchNorth = centerLat + delta.lat;

            // Filter vertices within the patch bounds
            const patchVertices = [];
            const vertexMap = new Map(); // Map original index to new index
            for (let i = 0; i < vertexData.length; i += 3) {
                const u = vertexData[i] / 32767;
                const v = vertexData[i + 1] / 32767;
                const lon = west + u * (east - west);
                const lat = south + v * (north - south);
                if (lon >= patchWest && lon <= patchEast && lat >= patchSouth && lat <= patchNorth) {
                    const height = minHeight + (vertexData[i + 2] / 32767) * (maxHeight - minHeight);
                    patchVertices.push({ lon, lat, height });
                    vertexMap.set(i / 3, patchVertices.length - 1);
                }
            }

            // Filter triangles that reference only the patch vertices
            const patchTriangles = [];
            for (let i = 0; i < triangleIndices.length; i += 3) {
                const a = triangleIndices[i];
                const b = triangleIndices[i + 1];
                const c = triangleIndices[i + 2];
                if (vertexMap.has(a) && vertexMap.has(b) && vertexMap.has(c)) {
                    patchTriangles.push(vertexMap.get(a), vertexMap.get(b), vertexMap.get(c));
                }
            }

            return { vertices: patchVertices, triangles: patchTriangles };
        }

        function savePatchToFile(patch) {
            const json = JSON.stringify(patch, null, 2);
            const blob = new Blob([json], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'himalayas_patch.json';
            a.click();
            URL.revokeObjectURL(url);
        }

        async function extractAndSavePatch() {
            showStatus('Calculating tile coordinates...');
            const { x, y } = calculateTileCoordinates(CENTER_LAT, CENTER_LON, ZOOM);
            showStatus(`Fetching tile z=${ZOOM}, x=${x}, y=${y}...`);
            const buffer = await fetchTerrainTile(ZOOM, x, y);
            if (!buffer) return;

            showStatus('Decoding terrain data...');
            const decodedData = decode(buffer);
            if (!decodedData) {
                showError(new Error('Failed to decode terrain data.'));
                return;
            }

            showStatus('Extracting 100m² patch...');
            const patch = extractPatch(decodedData, CENTER_LAT, CENTER_LON, PATCH_SIZE_METERS);
            if (patch.vertices.length === 0) {
                showStatus('No vertices found in the specified patch area.');
                return;
            }

            showStatus(`Extracted patch with ${patch.vertices.length} vertices and ${patch.triangles.length / 3} triangles. Saving to file...`);
            savePatchToFile(patch);
            showStatus('Saved terrain patch to "himalayas_patch.json".');
        }

        document.getElementById('extractPatchBtn').addEventListener('click', extractAndSavePatch);

        showStatus('Click the button to extract and save a 100m² terrain patch from the Himalayas.');
    </script>
</body>
</html>